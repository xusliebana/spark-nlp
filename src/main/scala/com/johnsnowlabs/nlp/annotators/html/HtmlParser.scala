package com.johnsnowlabs.nlp.annotators.html

import com.johnsnowlabs.nlp.annotators.sbd.pragmatic.SentenceDetector
import com.johnsnowlabs.nlp.{Annotation, AnnotatorModel}
import org.apache.spark.ml.param.Param
import org.apache.spark.ml.util.{DefaultParamsReadable, DefaultParamsWritable, Identifiable}

class HtmlParser(override val uid: String) extends AnnotatorModel[SentenceDetector] {

  import com.johnsnowlabs.nlp.AnnotatorType._

  def this() = this(Identifiable.randomUID("HTMLTtansformer2"))

  val tag: Param[String] = new Param[String](this, "tag", "The tag that we going to find the htlml content")

  /**
    * cleanupMode:
    * * all: Get the whole html tag
    * * content: Get the content of the hatml tag
    */
  val selector: Param[String] = new Param[String](this, "selector", "What Kind of selector we going to take possibles values all or content")

  def setTag(value: String): this.type = set(tag, value)

  def getTag: String = $(tag)

  def setSelector(value: String): this.type = {
    value.trim.toLowerCase() match {
      case "all" => set(selector, "all")
      case "content" => set(selector, "content")
      case b => throw new IllegalArgumentException(s"Special Character for Selector  supports only: " +
        s"content, String. Received: $b")
    }
  }

  def getSelector: String = $(selector)

  setDefault(
    outputCol -> DOCUMENT,
    selector -> "content"
  )

  /** Output annotator type : DOCUMENT
    *
    * @group anno
    * */
  override val outputAnnotatorType: AnnotatorType = DOCUMENT
  /** Input annotator type : DOCUMENT
    *
    * @group anno
    * */
  override val inputAnnotatorTypes: Array[AnnotatorType] = Array(DOCUMENT)

  /**
    * Uses the model interface to prepare the context and extract the boundaries
    *
    * @param annotations Annotations that correspond to inputAnnotationCols generated by previous annotators if any
    * @return One to many annotation relationship depending on how many sentences there are in the document
    */
  override def annotate(annotations: Seq[Annotation]): Seq[Annotation] = {
    selectTag(annotations)
  }

  private def selectTag(text: Seq[Annotation]): Seq[Annotation] = {
    val tagString = $(tag)
    val tags = tagString.split('.').toList
    getContentHtml(tags, text.map(annotation => ContentIndex(annotation.begin, annotation.begin, annotation.result, annotation.result)))
  }.map(contextIndex => selectAnnotator(contextIndex))

  private def selectAnnotator(contextIndex: ContentIndex): Annotation = {
    $(selector) match {
      case "all" => Annotation(
        DOCUMENT,
        contextIndex.tagIndex,
        contextIndex.tagIndex + contextIndex.tag.length - 1,
        contextIndex.tag,
        Map.empty)
      case "content" => Annotation(
        DOCUMENT,
        contextIndex.index,
        contextIndex.index + contextIndex.content.length - 1,
        contextIndex.content,
        Map.empty)
    }
  }

  private def regularFunction(tag: String) = s"<$tag.*>([\\s\\S]*?)</$tag>".r

  private def getContentHtml(tagsToExplore: Seq[String], contents: Seq[ContentIndex]): Seq[ContentIndex] = {
    if (tagsToExplore.isEmpty)
      contents
    else {
      val elements = contents.flatMap { contextIndex =>
        regularFunction(tagsToExplore.head)
          .findAllMatchIn(contextIndex.content)
          .map(matcher =>
            ContentIndex(contextIndex.index + matcher.start(1), contextIndex.index + matcher.start, matcher.group(1), matcher.matched)).toSeq
      }
      if (elements.isEmpty)
        Seq.empty[ContentIndex]
      else getContentHtml(tagsToExplore.tail, elements)
    }
  }


}

private case class ContentIndex(index: Int, tagIndex: Int, content: String, tag: String)

object HtmlParser extends DefaultParamsReadable[HtmlParser]

